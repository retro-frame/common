
===============================================================================
 ____      _                   _____                         
|  _ \ ___| |_ _ __ ___       |  ___| __ __ _ _ __ ___   ___ 
| |_) / _ \ __| '__/ _ \ _____| |_ | '__/ _` | '_ ` _ \ / _ \
|  _ <  __/ |_| | | (_) |_____|  _|| | | (_| | | | | | |  __/
|_| \_\___|\__|_|  \___/      |_|  |_|  \__,_|_| |_| |_|\___|


COMMON - Retro-Frame Common Documentation

Guidelines

Repository:  <http://source.retro-frame.net/common>
File:        /doc/rf-guide.txt//
Version:     01.00!01
Compliance:  Retro-Frame 1.0
License:     MIT

Copyright (c) 2025 Ingo Boehmer <ingo@retro-leisure.net>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===============================================================================


Change history
-------------------------------------------------------------------------------

2025-03-09 : 01.00!01 : Ingo : Draft


Contents
-------------------------------------------------------------------------------

1. INTRODUCTION
   1.1  Background
   1.2  Scope
   1.3  References

2. CONVENTIONS
   2.1  Name spelling
   2.2  Change histories
   2.3  Quotes and syntax notations
   2.4  Work file names
   2.5  File and directory references

3. SOFTWARE RELEASE LIFE CYCLE
   3.1  Pre-release (development, test)
   3.2  Release (initial, major or minor)
   3.3  Support (patch / correction, deprecation)

4. FILE SYSTEM AND REPOSITORIES
   4.1  Local paths
   4.2  Commits and tags
   4.3  Branching, merging and pull requests
   4.4  License and readme files
   4.5  Directory structures and exclusions

5. REPOSITORY TYPES AND LICENSING
   5.1  Manual repositories
   5.2  Offline repositories
   5.3  Private repositories
   5.4  Public repositories
   5.5  Collaborative repositories

6. VERSIONING
   6.1  Regular version numbers
   6.2  Repository versioning
   6.3  Work file versioning
   6.4  Product versioning
   6.5  Data format version numbers

7. SECURITY
   7.1  General considerations
   7.2  Classification of information
   7.3  Potential threats and risks
   7.4  Security levels



1. INTRODUCTION
===============================================================================


1.1 Background
-------------------------------------------------------------------------------

[RETRO-FRAME] is a Retro-Endeavor that provides common documentation (i.e.
definitions, guidelines and templates) as well as specifications which are
intended for use in retrospective programming and may be used as a whole or
partially for other purposes.

As Retro-Frame is evolving, declarations of compliance should always refer to a
specific release version. If a general intention of compliance is expressed, a
reference to the major version may be given by "Retro-Frame 1.x". However, an
actual reference should specify the minor version as well (e.g. "Retro-Frame
1.0").

Note that the individual Retro-Frame specifications (e.g. data formats) may use
independent version numbers.


1.2 Scope
-------------------------------------------------------------------------------

This document provides GUIDELINES (i.e. normative rules) which must be
observed, depending on the [REQUIREMENT LEVEL KEYWORDS] used, in order to
comply to this version of Retro-Frame.

While all Retro-Frame guidelines are covered by this single document, other
Retro-Endeavors may provide subsidiary guidelines.


1.3 References
-------------------------------------------------------------------------------

[MARKDOWN]
Markdown homepage by John Gruber, Daring Fireball Company LLC., see
<https://daringfireball.net/projects/markdown/>.

[MIT LICENSE]
MIT License, see <https://en.wikipedia.org/wiki/MIT_License>.

[REQUIREMENT LEVEL KEYWORDS]
RFC: 2119 - Key words for use in RFCs to Indicate Requirement Levels, see
<https://datatracker.ietf.org/doc/html/rfc3986>.

[RETRO-FRAME]
Retro-Frame Common Documentation, see <http://source.retro-frame.net/common>.

[SEMANTIC VERSIONING]
Semantic Versioning 2.0.0, originally authored by Tom Preston-Werner, see
<https://semver.org/>.

[URL]
RFC: 3986 - Uniform Resource Identifier (URI): Generic Syntax, see
<https://datatracker.ietf.org/doc/html/rfc3986>.



2. CONVENTIONS
===============================================================================


2.1 Name spelling
-------------------------------------------------------------------------------

If part of a text, including comments of source files, the "Retro" prefixed
words should be hyphenated and capitalized (e.g. Retro-Leisure, Retro-Frame,
Retro-BASIC or Retro-C). Note that BASIC is considered an acronym and thus
fully capitalized.

If part of an account or domain name, all words should be spelled in lower case
(e.g. retro-leisure, retro-frame, retro-basic or retro-c).

In cases where text is fully capitalized (e.g. a top level caption), the words
must be fully capitalized just like the rest (e.g. RETRO-LEISURE, RETRO-FRAME,
RETRO-BASIC or RETRO-C).


2.2 Change histories
-------------------------------------------------------------------------------

In order to keep formal guidelines low, a change history is only required for
each new version of a DOCUMENT that is considered final (i.e. a release or
correction version, see chapters 3.2 and 3.3). The format of a change history
entry is determined by the document template (see /rf-template.txt//).

While a version is not considered final, the description should be "Draft" and
the date may be updated at discretion.

When a version becomes final, the description should be "Initial version" on
the first entry or a brief summary of the changes in relation to the previous
entry otherwise. Also, the date must be updated each time the document is
changed.

In case a document becomes deprecated (but should not be deleted for any
reason), a final entry should be made, using "INVALID" instead of the version
number, and the description should be "Withdrawn".


2.3 Quotes and syntax notations
-------------------------------------------------------------------------------

A single character should be enclosed by single quotes (i.e. apostrophes ''').
Note that an apostrophe itself may be represented in that way and that a
sequence of more than one character enclosed by apostrophes is considered a
term to be defined (see /rf-def.txt//, chapter 2.1).

A text literal (i.e. a fixed sequence of characters) should be enclosed by
double quotes (i.e. quotation marks '"'). If a quotation mark itself is part of
the text literal, it is represented by two quotation marks (e.g. """X"""). 

In order to specifiy a more complex syntax of a text (e.g. in a document), the
Retro-Frame metasyntax should be used (see /spec/rf-syntax.txt//, chapter 2).
Additional terminal symbols may be defined in the respective context.

In order to specifiy the syntax of a text data format, the text data format
specification syntax should be used (see /spec/rf-syntax.txt//, chapter 3).

In order to specifiy the syntax of a binary data format, the binary data format
specification syntax should be used (see /spec/rf-syntax.txt//, chapter 4).


2.4 Work file names
-------------------------------------------------------------------------------

A WORK FILE name should consist of an optional prefix, the base name and an
optional suffix:

  [_<work-file-prefix>_]_<work-file-base-name>_[_<work-file-suffix>_]

The prefix, if given, must be equal for all files in the same directory, should
start with a letter ('A'-'Z', 'a'-'z'), followed by a sequence of letters,
digits ('0'-'9'), hyphens ('-') or low lines ('_'), and end with a hypen or a
low line:

<work-file-prefix>:

  ?_[_?_|_9_|_"-"_|_"_"]*_(_"-"_|_"_"_)

The base name should start with a letter, digit or dollar sign ('$'), followed
by a sequence of letters, digits, hyphens, low lines or dollar signs:

<work-file-base-name>:

  (_?_|_9_|_"$"_)_[_?_|_9_|_"-"_|_"_"_|_"$"_]*

The suffix, if given, should start with a period ('.'), followed by a non-
empty sequence of letters, digits or dollar signs:

<work-file-suffix>:

  "."_(_?_|_9_|_"$"_)*

In general, work file names are stored case sensitive but compared case
insensitive. Thus, even if the file systems respective REPOSITORIES compares
file names case sensitive, two work file names in the same directory must
always be different if compared ignoring the case.

The total length prefix and base name together should not exceed 39 characters,
the length of a base name should not exceed 8 characters and the length of a
prefix should not exceed 3 characters. However, if the repository is limited
to specific environments, which all support file names of up to 39 characters
and suffixes of up to 6 characters, the length of a base name may exceed 8
characters and the length of a suffix may exceed 3 characters but should not
exceed 6 characters.


2.5 File and directory references
-------------------------------------------------------------------------------

Files and directories should be referenced by a [URL] if accessible over the
Internet, or by a universal path (see /spec/rf-path.txt) if located on a file
system (e.g. repository, local disc or mounted network drive).

A URL should always be enclosed by '<' and '>'.

If a universal path is used, native encodings (including native selectors)
should be avoided whenever possible (an exception may be, for example, a
specification concerning a specific native environment). However, native
selectors may be used to describe an unknown native base path. In this case,
the description should be enclosed by '<' and '>' (e.g. [<base-path>]). The
universal root selector (i.e. "/") refers to the repository of which the work
file belongs to (for expample, the root of universal path references in this
document is the repository <http://source.retro-frame.net/doc>). A universal
path should always end with a type mark (i.e. "//" for a file respective "/"
for a directory) unless the path may refer to either (i.e. a file or a
directory).



3. SOFTWARE RELEASE LIFE CYCLE
===============================================================================

Retro-Frame uses a simplified concept for the SOFTWARE release life cycle using
the stages pre-release, release and support. In general, the software release
life cycle also applies on DOCUMENTATION.

As development and support depends on uncertain contribution, there is no
explicit end-of-life stage. A retro software product may suddenly become
end-of-life because there are no more contributions to it. On the other hand, a
new contributor may continue a retro software which already has been considered
end-of-life.


3.1 Pre-release (development, test)
-------------------------------------------------------------------------------

During development, if a version of a SOFTWARE is at least partially usable, it
may be marked as a pre-release. While the version of a pre-release is fixed and
can be referred to by means of an individual version number, the development
process has not been finished and the software may still be changed. In fact,
there are no compatibility requirements between pre-releases so that a software
may even be entirely redeveloped during pre-release.

If a software is considered final and ready for test, pre-release stages may be
indicated by using the greek alphabet (alpha, beta et cetera). In this case,
changes on the software should be restricted to bug fixing and after each fix,
the pre-release version number must be increased (while the stage may or may
not be changed).


3.2 Release (initial, major or minor)
-------------------------------------------------------------------------------

Goal of development is always the release of a SOFTWARE which may be either an
initial, major or minor release.

While the initial release is the first release of a software at all, a major
release may entail substancial changes of the software and no compatibility
requirements must be met (just like between pre-releases). Thus, a major
release may be entirely different from previous major releases or the initial
release. In extreme consequence, just the name of the software remains the
same.

In contrast, a minor release is based on an initial or major release and must
meet compatibility requirements. In general, a minor release is expected to be
fully backward compatible:

- A minor release of a software may add functionalitiy or capabilities but must
  provide all functionality and capabilities of previous minor releases. In
  addition, there should be no significant modifications of the user interface.

- A minor release of DOCUMENTATION may add DEFINITIONS and more restrictive
  GUIDELINES but must preserve definitions and guidelines of previous minor
  releases. Note that due to backward compatibility in this sense, compliance
  to a release which contains both, definitions and guidelines, does not entail
  implicit compliance to another minor version (while a lower minor version may
  not provide all definitions used, a higher minor version may have additional
  guidelines which are not satisfied).

For SPECIFICATIONS, the exact meaning of backward compatibility depends of thy
type of the specification:

- A minor release of an API may add functions or declarations but must provide
  all functions or declarations of previous minor releases. Existing functions
  may have additional parameters or capabilities as long as functions calls
  conforming to the previous minor release of the API remain compatible (e.g.
  if optional parameters are provided, a new optional parameter may be appended
  to the parameter list or a function parameter specifies an action, additional
  actions may be recognized while existing actions remain unchanged).

- A minor release of a DATA FORMAT may add elements or interpretations but
  remain a valid format according to previous minor releases. This results in
  forward compatibility of implementations which expect a specific minor
  version data format (the added elements or interpretations will be ignored).
  As a special case of backward compatibility requirements, implementations
  which support a specific data format release should also support lower major
  releases unless deprecated (see chapter 5.5).

- A minor release of an ENVORONMENT

- A minor release of a PROTOCOL should accept lower minor releases of one or
  more of the participants. If this is not implicitly achieved by the design of
  the protocol, the minimum minor release should be negotiated.

For types of specifications which are not included in this list, an analogous
meaning of backward compatibility should be applied.


3.3 Support (patch / correction, deprecation)
-------------------------------------------------------------------------------

After release, a software may still be supported in order to fix bugs and/or
security issues when they become known by means of a patch. In terms of
documentation, errors which need correction may be identified after release.

A patch is not supposed to add or change functionality except fixing the
problem.

If a severe bug and/or security issue is known but fixing is not possible or
considered too complex, the release may be deprecated. In this case, a patch
should be created anyway which at least indicates deprecation. A new patch
which fixes the problem may be created so that the release becomes valid again
(thus, deprecation of a release is not considered final).



4. FILE SYSTEM AND REPOSITORIES
===============================================================================

All workfiles should be part of a REPOSITORY. Access control, version control
(i.e. commits, branches, tags and pull requests), backup and licensing always
affects the entire repository.


4.1 Local paths
-------------------------------------------------------------------------------

There should be a dedicated directory for each Retro-Endeavor, which is of
interest, on the local file system. It is recommended to choose an appropriate
common base directory and to create a directory for each Retro-Endeavor using
its name as the directory name (if possible), for example:

  :Retro-Frame/
  :Retro-BASIC/
  :Retro-C/

If not all directory names would be allowed by the file system, the initials
of the Retro-Endeavors may be used in uppercase and without the hyphen, for
example:

  :RF/
  :RB/
  :RC/

In each Retro-Endeavor directory, the following sub-directories should be used
as the mount point for REPOSITORIES:

- The sub-directory dev/ should be the mount point for development repositories
  whose work files may be modified by development activities. Note that during
  development, the repository may not have a valid version (see chapter 6).

- The sub-directory release/ should be the mount point for release repositories
  whose work files must have a fixed version state and must not be modified any
  more. If all versions and dependencies haven been chosen properly, a clean
  build may be performed and/or program files may be executed.

Additional sub-directories may be used (e.g. to keep multiple versions of
documentation or libraries in parallel, to make program files executable from
the command line or to collect individual files of a PRODUCT). However, those
parts remain unspecified.

If a repository is created, exported or cloned to such a mount point, the local
relative path of the repository should be the name of the repository except
that if the name contains periods ('.'), each part of the name separated by the
periods should be a separate directory (i.e. the periods should be replaced by
an environment-dependent path separator).

Examples:

- Local path for development of the Retro-Frame repository "common":
  :Retro-Frame/dev/common/

- Local path for releases of the Retro-BASIC repository "test":
  :Retro-BASIC/release/test/

- Local path for development of the Retro-C repository "comp.stdc.recma55":
  :Retro-C/dev/comp/stdc/recma55/


4.2 Commits and tags
-------------------------------------------------------------------------------

A REPOSITORY must provide a commit mechanism, which preserves a certain state
of all comprised files and may be called a snapshot.

Each commit should be identifiable by a timestamp, representing the current
date and time when the commit took place. The timestamp must be UTC except
while the repository resides on the local filesystem, in which case the
timestamp may also be local time.

In addition, a repository shall provide tags (sometimes called labels) which
may be used to associate a specific commit with a text string.

It must be possible to retrieve (i.e. check out or export) an arbitrary commit
state at any time.


4.3 Branching, merging and pull requests
-------------------------------------------------------------------------------


4.4 License and readme files
-------------------------------------------------------------------------------

If licensing is provided for a repository (see chapter 5), the license text
including a copyright notice should be stored as a plain text file "LICENSE"
which should be located in the root directory of the repository.

In addition, each repository should contain a readme file which provides

-
-

The readme file should either be a plain text file "README" or a [MARKDOWN]
file "README.md" and should also be located in the root directory of the
repository.


4.5 Directory structures and exclusions
-------------------------------------------------------------------------------

- build, doc, src, test

Directories or sub-directories starting with a commercial at symbol ('@')
should be excluded from all repositories. Such directories may be used for
files which are related to the repository but should remain on the local
filesystem only.

In addition, directories and/or files which contain temporary or generated data
(i.e. are no WORK FILES) should also be excluded. The specification of such
files depends on the development environment.



5. REPOSITORY TYPES AND LICENSING
===============================================================================


5.1 Manual repositories
-------------------------------------------------------------------------------

A manual REPOSITORY is maintained on a local disk. Access control, branching
and backup must be performed manually on the file system. Commits are done by
packing the entire repository as a ZIP file whose name shall consist of the
repositorie's name, a timestamp in the format YYYYMMDDHHMM and one or more
optional tags, all separated by low lines ('_').

As the repository is not published, no licensing is required.


5.2 Offline repositories
-------------------------------------------------------------------------------

An offline REPOSITORY is maintained on a local filesystem by means of a version
control system (e.g. Git) which should support automated commits, branching and
merging. Access control and backup has to be performed manually.

As the repository is not published, no licensing is required.


5.3 Private repositories
-------------------------------------------------------------------------------

A private REPOSITORY is maintained on a version control platform (e.g. GitHub)
which should provide access control and backup facilities. A pull request
mechanism is recommended.

The owner of such a repository may be a person or a technical user. The owner
may grant read access to individual users and write access to contributers.
Each contributer may maintain a local clone of the online repository.

The online repository should be referenced by a fixed URL. This URL may be the
standard URL of the version control platform or a private URL.

As the repository is not published to the public, licensing is not required but
recommended.


5.4 Public repositories
-------------------------------------------------------------------------------

A public REPOSITORY is maintained on a version control platform (e.g. GitHub)
which should provide access control and backup facilities. A pull request
mechanism is recommended.

The owner of such a repository may be a person or a technical user. Read access
is not restricted (i.e. the repository is public readable). The owner may grant
write access to contributers. Each contributer may maintain a local clone of
the online repository.

The online repository should be referenced by a fixed URL. This URL may be the
standard URL of the version control platform or a private URL.

As the repository is published to the public, licensing is required. In order
to ensure high license compatibility, each Retro-Frame compliant public
repository should be published under the [MIT LICENSE].


5.5 Collaborative repositories
-------------------------------------------------------------------------------

A collaborative REPOSITORY is maintained on a version control platform (e.g.
GitHub) which should provide access control, backup facilities and a pull
request mechanism.

The owner of such a repository should be a technical user. Read access is not
restricted (i.e. the repository is public readable). The owner may grant write
access to maintainers and pull requests to individual contributers or public.
Each contributer may maintain a local clone of the online repository.

The collaborative repository should be referenced by a fixed URL. This URL may
be the standard URL of the version control platform or a private URL.

As the repository is published to the public, licensing is required. In order
to ensure high license compatibility, each Retro-Frame compliant collaborative
repository should be published under the [MIT LICENSE].



6. VERSIONING
===============================================================================

Retro-Frame follows the ideas of [SEMANTIC VERSIONING] but does not fully
comply with it.


6.1 Regular version numbers
-------------------------------------------------------------------------------

A <major-version> number is a decimal value in the range 1..16 and, if it
stands for its own, represented as by one of the following formats:

- Fixed width major version number representations always use two decimal
  digits. If the value of the major version is less than 10, a leading zero
  ('0') is prepended.

- Variable width major version number representations also use decimal digits
  but no leading zeros and ".x" (or ".X" if lowercase letters are not provided)
  is appended.

All other regular version numbers consist of two or three version elements,
where each element is a decimal number and the elements are separated by
a period ('.') or an exclamation mark ('!'). There are two textual
representations of regular version numbers (binary representations are
unspecified):

- Fixed width version number representations always use two decimal digits for
  each element. If the value of one element is less than 10, a leading zero
  ('0') is prepended.

- Variable width version number representations also use decimal digits but no
  leading zeros. If it is not clear by context that the format represents a
  version number, a leading 'v' (or 'V' if lowercase letters are not provided)
  is prepended.

Pre-release version numbers are in the format

  <major-version>_'.'_<minor-version>_'!'_<pre-release>

where <major-version> is in the same range as described above, <minor-version>
is in the range 0..31 and <pre-release> is in the range 0..94 (e.g. 01.23!08
respective v1.23!8). For a new pre-release, <pre-release> is incremented by one
until the version is released.

Release version numbers are in the format

  <major-version>_'.'_<minor-version>

where <major-version> and <minor-version> are in the same range as described
above (e.g. 01.23 respective v1.23). An initial release always has version
number 01.00 respective v1.0 and for a new major release, <major-version> is
incremented by one while <minor-version> is set to zero. For a new minor
release, <major-version> remains unchanged and <minor-version> is incremented
by one. 

Patch respective correction version numbers are in the format

  <major-version>_'.'_<minor-version>_'.'_<patch>

where the range of <major-version> and <minor-version> are in the same range
as described above and <patch> should be in the range 0..31 (e.g. 15.02.03
respective v15.2.3). The initial release version has always <patch> set to
zero. For each patch respective correction, <patch> is incremented by one.


6.2 Repository versioning
-------------------------------------------------------------------------------

As a REPOSITORY represents a sequence of individual commits, the repository
itself has no version. However, a specific commit may be considered a version.
In this case, the pre-release or patch version should be specified by means of
a tag.

Thus, if a specific commit associated with a version tag is retrieved from the
repository, the resulting files have a defined version according to the tag.

In the following cases, as second tag should be added:

- If a pre-release version is considered a new test stage, a tag representing
  the stage (i.e. "alpha", "beta" et cetera).

- If a patch version is considered deprecated, the tag "deprecated".

Commits without a version tag do not have a version. The latest commit is
called the head. Thus, the head represents the current state of development
(which may not have a version yet).

If branches are used and commits with the same tag(s) occur in multiple
branches, the state must be identical. However, each branch has its own head.

The readme file of the repository should always represent the current version
number. If changes are made after a commit with a version tag, the pre-release
respective patch version should be incremented by one and "(dev)" should be
appended to the version number until the changes become a new version.


6.3 Work file versioning
-------------------------------------------------------------------------------

If a WORK FILE shows a version number (either in the source or as output when
executed), the release version number must be the same than the release version
number of the latest version tag (or, if no latest version tag exists on a
branch, the next version tag in future).

The pre-relase respective patch version of a work file may be individual for
the file. However, it must not be higher than the one of the current version
tag, if one is given. If the work file is in the head an the head does not have
a version tag, the pre-release respective patch version must equal the one of
the last tag incremented by one (respective zero if no tag exists).

Example:

- Work files A and B are part of a commit with tag 01.00!00. Both should show
  the same pre-release version number.

- In a new commit, work file A is changed to pre-release version 01.00!01. Work
  file B still shows version 01.00!00.

- This or a subsequent commit is versioned by the tag 01.00!01.

- In a new commit, work file B is changed from pre-release version 01.00!00 to
  pre-release version 01.00!02.

- The next version tag of a commit should be 01.00!02.

If the version tag is a new test stage or a release (i.e. patch version is set
to zero), all work files must show exactly the same version.


6.4 Product versioning
-------------------------------------------------------------------------------

If a PRODUCT comprises multiple SOFTWARE and/or DOCUMENTATION components, each
component should have the same release version like the product.

The pre-relase respective patch version of the product should be the maximum of
those of the individual components. Thus, if a patch is applied to one or more
components, the product's patch version number should be incremented by one and
the resulting number should be used for all components which have been changed
for the patch.


6.5 Data format version numbers
-------------------------------------------------------------------------------

DATA FORMAT version numbers are in the format

  <major-version>_':'_<minor-version>

where both, <major-version> and <minor-version>, are in the range 0..255 for
binary formats and in the range 33..126 for text formats at maximum. However,
for each major version the allowed range of the minor version may be more
restricted.

The textual representation of a data format version numbers always uses two
hexadecimal digits for each element. If the value of one element is less than
10 (i.e. 16 decimal), a leading zero ('0') is prepended (e.g. 0A:03).

Implementations which support data format versions should be upward compatible,
if the major version number is unchanged, for increasing minor version numbers
(i.e. elements which are not recognized are ignored).

The specification of the data format may deprecate a version. In this case,
implementations should not create data formats of this version but may still
read them (in which case the user should be warned that a deprecated data
format is used). Either the entire major version number or a minor version
number of the data format may become deprecated. In the first case, deprecation
affects only the single major version. In the second case, deprecation also
affects all lower minor version numbers of the same major version number. In
both cases, deprecation should be permanent.

Thus, for each major version, the minimum and maximum minor version as well as
an optional deprecated minor version (which must be in that range) must be
recognized. If a deprecated minor version equals the maximum minor version, the
entire major version is considered deprecated.

Implementations should always support lower major version numbers or lower
minor version numbers of the same major version number unless deprecated. Thus,
no new minor version number must be created as soon as a new major version
number is released. Deprecated versions should be recognized as soon as the
implementation becomes aware of deprecation.



7. SECURITY
===============================================================================


7.1 General considerations
-------------------------------------------------------------------------------

Security is a rather difficult aspect of retro programming. On the one hand,
even retro software should be secure. On the other hand, security has often
been neglected in the past and it may be necessary (e.g. due to cryptographic
compatibility) or even fun (e.g. to try to exploit a retro software) to
produce less secure programs.

As the Retro-Endeavors focus on development, security considerations are
limited to the SOFTWARE itself. Other environmental aspects which may have
great influence on the security respective the risks (e.g. network access
control, user rights, system configuration or sandboxing) are out of scope and
need to be considered separately.

In addition, the impact of security threats heavily depends on the value which
the affected assed has to the user. Thus, two classes of security threats
should be distinguished:

- Threats which affect the information processed by the PRODUCT which is build
  from SOFTWARE developed by a Retro-Endeavor. In order to respect the
  individual values those information may have to the user, classification of
  information is used to assess the potential impact in case of loss of
  confidentiality, integrity and/or availability (see next chapter).

- Threats which affect the ENVIRONMENT (i.e. the system) in which the product
  is executed. While the potential impact in these cases may vary, this is
  always considered to have the highest impact.


7.2 Classification of information
-------------------------------------------------------------------------------

In order to simplify the classification of information, only a scalar level of
sensitivity is used which is determined by the potential impact in case of the
loss of one or more of the following security objectives:

- Confidentiality (i.e. no unauthorized disclosure of information).

- Integrity (i.e. no unauthorized modification of information).

- Availability (i.e. information can be processed when required).


Level   Criteria
------  -----------------------------------------------------------------------
none    Information may be publicly available. There is no security objective
        or the loss a secrity objective would be insignificant.
low     Access to information should be restricted to the local network and the
        loss of a secrity objective would be neglectable.
medium  Access to information should be restricted to the execution environment
        and the loss of a secrity objective could have moderate impact.
high    Access to information should be restricted to individual users and the
        loss of a secrity objective could have severe impact.


If the levels of sensitivity differ for the individual security objectives, the
highest (i.e. maximum) level is chosen.


7.3 Potential threats and risks
-------------------------------------------------------------------------------


7.4 Security levels
-------------------------------------------------------------------------------

The aimed level of security should be defined for each PROGRAM FILE. It may
either be fixed (and should not be changed within the major release) or the
security level may be selectable on compile-time or even on run-time.

Security level "insecure":

- The security level "insecure" indicates that a program file is intentionally
  insecure. If not used properly, the execution of the program file(s) may
  cause severe harm not only regarding the confidentiality and integrity of the
  information processed by the product but also for the environment in which
  the respective program files are executed.

- Whenever a program file on this security level is started, the user must be
  warned in a clear and emphasized manner and explicitly and interactively
  confirm (e.g. by typing a sequence of characters which is randomly chosen by
  the program) before any insecure operation is executed.

Security level "low":

- The security level "low" indicates that security has not been explicitly
  considered or known weak operations are included, which however must not
  entail any known risk for the environment (e.g. a buffer overflow) and even
  the confidentiality or integrity of the data processed by the program which
  require protection may only be impacted under certain preconditions (e.g.
  storing credentials in clear text on a filesystem).

- Cryptographic algorithms which are known to be broken are always considered
  weak operations (this may lead to cases where unencrypted processing of non-
  sensitive data is not considered a weak operation while encrypting the same
  data with a broken algorithm is considered a weak operation in order to avoid
  a false sense of security).

- Whenever a program file on this security level is started, the user must be
  warned. Before weak operations become effective, the user's agreement should
  be confirmed by a simple mechanism (e.g. a defined keystroke or a command
  line argument). If the user's agreement is given before the program file is
  started, the warning may be omitted.

Security level "medium":

- The security level "medium" indicates that security has been considered but
  not explicitly verified (e.g. by means of a peer-review or a penetration
  test). In addition, weak user choices, which may impact the confidentiality
  or integrity of the data processed, are not prevented (e.g. less complex
  passwords).

- This includes cryptographic algorithms which are considered weak or
  deprecated (e.g. DES or MD5) and may be chosen by the user arbitrarily or
  negotiated (e.g. by a network protocol).

- This security level is considered the default mode of retro programming.
  Thus, an explicit warning or even confirmation is not required but a hint
  should be printed on the version / license output.

Security level "high":

- The security level "high" indicates that security has been considered and is
  considered strong according to current standards. No insecure operations are
  allowed. Weak or deprecated operations respective cryptographic algorithms
  are allowed but require an explicit warning and confirmation by the user.

- This security level must only be assumed if stated explicitly.

Details regarding the security level(s) and specific security risks should be
described in the readme file of the REPOSITORY.
